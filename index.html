<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>img2txt-h v0.13b</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --sidebar-bg: #2d2d2d;
            --text-color: #eee;
            --input-bg: #444;
            --border-color: #555;
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --success-color: #28a745;
            --link-color: #58a6ff; 
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: row; 
            overflow: hidden; 
        }

        /* --- Toast é€šçŸ¥ --- */
        #toast-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3000;
            pointer-events: none;
            width: 90%;
            max-width: 400px;
            text-align: center;
        }
        
        .toast {
            background-color: rgba(40, 40, 40, 0.95);
            color: #fff;
            padding: 10px 20px;
            border-radius: 50px;
            margin-bottom: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            font-size: 14px;
            opacity: 0;
            transform: translateY(-20px);
            transition: opacity 0.3s, transform 0.3s;
            border-left: 5px solid var(--primary-color);
            display: inline-block;
        }
        
        .toast.show { opacity: 1; transform: translateY(0); }
        .toast.success { border-left-color: var(--success-color); }
        .toast.error { border-left-color: #dc3545; }

        /* --- ç§»åŠ¨ç«¯èœå•æŒ‰é’® --- */
        #mobile-menu-btn {
            display: none; 
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 2100; 
            background-color: var(--sidebar-bg);
            color: #fff;
            border: 1px solid var(--border-color);
            padding: 8px 16px;
            border-radius: 30px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            font-size: 14px; 
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        #mobile-menu-btn:active { transform: scale(0.95); }
        @media (min-width: 769px) { #mobile-menu-btn { display: none !important; } }

        /* --- ç§»åŠ¨ç«¯é®ç½©å±‚ --- */
        #mobile-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 2150;
            opacity: 0;
            transition: opacity 0.3s;
            backdrop-filter: blur(2px);
        }
        #mobile-overlay.active { display: block; opacity: 1; }

        /* --- å·¦ä¾§å·¥å…·æ  --- */
        .sidebar {
            width: 340px;
            background-color: var(--sidebar-bg);
            padding: 5px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 5px;
            overflow-y: auto;
            flex-shrink: 0;
            z-index: 2000;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
            text-align: center;
            color: #fff;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
            background: rgba(0,0,0,0.15);
            padding: 6px 10px;
            border-radius: 6px;
        }

        label {
            font-size: 0.85em;
            color: #ccc;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2px;
        }

        .val-display { font-family: monospace; color: var(--primary-color); font-weight: bold; }

        select, input[type="file"], input[type="number"], input[type="text"], input[type="range"], button {
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--input-bg);
            color: white;
            width: 100%;

            box-sizing: border-box;
            font-size: 13px;
        }

        input[type="range"] { padding: 0; border: none; background: transparent; cursor: pointer; margin: 4px 0; }
        button { cursor: pointer; font-weight: bold; transition: 0.2s; }
        
        button.primary-btn {
            background-color: var(--primary-color);
            border: none;
            padding: 12px;
            margin-top: 5px;
            font-size: 14px;
        }
        button.primary-btn:hover { background-color: var(--primary-hover); }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }
        .btn-full { grid-column: 1 / -1; }

        button.action-btn { background-color: #444; border: 1px solid #666; }
        button.download-btn { background-color: #e0a800; color: #000; border: none; }

        #drop-zone {
            border: 1px dashed var(--border-color);
            padding: 10px;
            text-align: center;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            background-color: #333;
            cursor: pointer;
            transition: 0.2s;
            color: #aaa;
            font-size: 0.85rem;
            display: flex;
            gap: 10px;
        }
        #drop-zone span { font-size: 18px !important; }
        .compact-row {
    display: grid;
    grid-template-columns: 1fr 1fr; /* ä¸¤åˆ—ç­‰å®½ */
    gap: 8px;
}

        /* --- åº•éƒ¨èµ„è®¯ä¸ Iframe --- */
        .sidebar-footer {
            margin-top: auto; 
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
            font-size: 0.9em;
        }

        .footer-info h6 {
            margin: 8px 0;
            font-size: 0.85rem;
            color: #bbb;
            font-weight: normal;
            line-height: 1.5;
        }

        .footer-info a {
            color: var(--link-color) !important;
            text-decoration: none;
        }
        .footer-info a:hover { text-decoration: underline; }

        .iframe-wrapper {
            margin-top: 5px;
            width: 100%;
            height: 80px; 
            overflow: hidden; 
            position: relative;
        }

        /* --- å³ä¾§å†…å®¹åŒº --- */
        .main-content {
            flex-grow: 1;
            padding: 40px;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* å†…å®¹ä»é¡¶éƒ¨å¼€å§‹ */
            background-color: #000; 
            transition: background-color 0.3s;
            -webkit-overflow-scrolling: touch;
        }

        #ascii-output {
            font-family: 'Courier New', Courier, monospace; 
            font-size: 10px; 
            line-height: 1.0; 
            white-space: pre; 
            user-select: text;
            width: auto;
            height: auto;
            transform-origin: top center;
        }

        /* [NEW] æ¬¢è¿é¡µ ASCII è‰ºæœ¯é£æ ¼å®¹å™¨ */
        .placeholder-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-top: 15vh;
            pointer-events: none;
            /* æ¡Œé¢ç«¯é»˜è®¤æ¯”ä¾‹ */
            transform-origin: top center;
        }

        /* ASCII è‰ºæœ¯å­—ï¼šæ¸å˜è‰²å—é£æ ¼ 
           ä½¿ç”¨ linear-gradient å¡«å……æ–‡å­—é¢œè‰²ï¼Œå®ç°ä» â–ˆ åˆ° â–‘ çš„è§†è§‰æ•ˆæœ
        */
        .ascii-art-title {
            font-family: 'Courier New', monospace;
            white-space: pre;
            line-height: 1.0;
            font-weight: bold;
            color: #eee;
            margin-bottom: 2px;
            /* æ¸å˜æ•ˆæœ */
            background: linear-gradient(180deg, #ffffff 0%, #aaaaaa 40%, #555555 80%, #222222 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 5px rgba(255,255,255,0.1);
        }

        /* ä¸­æ–‡å‰¯æ ‡é¢˜ï¼šæ¨¡æ‹Ÿåƒç´ è‰²å— 
           ä½¿ç”¨ heavy font + text-shadow + gradient æ¨¡æ‹Ÿ "ç”¨è‰²å—åšæˆ" çš„æ„Ÿè§‰
        */
        .ascii-sub-title {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            font-size: 4rem; 
            font-weight: 900;
            letter-spacing: 4px;
            text-align: center;
            line-height: 1.2;
            
            /* æ¨¡æ‹Ÿè‰²å—æ¸å˜ */
            background: linear-gradient(180deg, 
                #ffffff 20%,  /* â–ˆ æœ€äº® */
                #bbbbbb 50%,  /* â–“ ç¨æš— */
                #777777 70%,  /* â–’ æš— */
                #444444 90%   /* â–‘ æœ€æš— */
            );
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            
            /* å¢åŠ åƒç´ å—é˜´å½± */
            filter: drop-shadow(4px 4px 0px #000);
            
            /* é¡¶éƒ¨è¾¹æ¡†è£…é¥° */
            border-top: 4px dashed #444;
            padding-top: 10px;
            margin-top: 10px;
        }

        /* --- RWD é€‚é… --- */
        @media (max-width: 768px) {
            #mobile-menu-btn { display: flex !important; }
            .sidebar { 
                position: fixed;
                left: 0; top: 0; height: 100%; width: 300px; 
                transform: translateX(-100%);
                z-index: 2200;
            }
            .sidebar.active { transform: translateX(0); }
            
            .main-content {
                padding: 70px 10px 20px 10px;
                width: 100%;
                justify-content: center;
                align-items: flex-start; 
                overflow-x: hidden;
            }

            /* [CORE] æ‰‹æœºç«¯æ™ºèƒ½ç¼©æ”¾ */
            .placeholder-wrapper {
                margin-top: 12vh;
                /* ä½¿ç”¨ clamp å’Œ vw åŠ¨æ€è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼Œé˜²æ­¢çˆ†ç‰ˆ */
                transform: scale(calc(100vw / 800)); 
                width: 100%;
            }
            /* é’ˆå¯¹ç‰¹åˆ«å°çš„å±å¹•å¾®è°ƒ */
            @media (max-width: 400px) {
                .placeholder-wrapper { transform: scale(0.4); }
            }
        }
    </style>
</head>
<body>

    <div id="toast-container"></div>

    <div id="mobile-overlay" onclick="toggleSidebar(false)"></div>
    
    <button id="mobile-menu-btn" onclick="toggleSidebar(true)">
        âš™ï¸ è°ƒæ•´å‚æ•°
    </button>

    <aside class="sidebar" id="sidebar">
        <div class="logo">img2txt-h v0.13b</div>

<div id="drop-zone" onclick="document.getElementById('imageInput').click()">
    <span>ğŸ“</span> ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ å›¾ç‰‡
    <input type="file" id="imageInput" accept="image/*" style="display:none">
</div>
        
<div class="compact-row">
    <div class="control-group">
        <label>å®½åº¦ <span id="widthVal" class="val-display">120</span></label>
        <input type="number" id="widthInput" value="120" min="20" max="800" oninput="document.getElementById('widthVal').innerText = this.value">
    </div>
    <div class="control-group">
        <label>è¾“å‡ºå­—å· <span id="zoomVal" class="val-display">10px</span></label>
        <input type="number" id="zoomInputNum" value="10" min="1" max="88" oninput="updateFontSize(this.value); document.getElementById('zoomInput').value=this.value">
        </div>
</div>
<input type="range" id="zoomInput" min="2" max="88" step="1" value="10" style="display:none" oninput="updateFontSize(this.value)"> 


<div class="compact-row">
    <div class="control-group">
        <label>é•¿å®½æ¯” <span id="ratioVal" class="val-display">0.55</span></label>
        <input type="range" id="ratioInput" min="0.3" max="1.0" step="0.01" value="0.55" oninput="document.getElementById('ratioVal').innerText = this.value" style="width:100%">
    </div>
    <div class="control-group">
        <label>æŠ–åŠ¨ç®—æ³•</label>
        <select id="ditherAlgo" style="width:100%">
            <option value="fs">Floyd-Steinbergå¹³è¡¡</option> 
            <option value="atkinson">Atkinsoné«˜æ¯”</option>
            <option value="stucki">Stuckié”åˆ©</option>
            <option value="bayer">Bayerç½‘çº¹</option>
            <option value="none">Noneæ— </option>
        </select>
    </div>
</div>

<div class="control-group" style="flex-direction: row; align-items: center; justify-content: space-between; padding: 4px 10px;">
    <label for="edgeCheck" style="margin:0; cursor:pointer;">è¾¹ç¼˜æ£€æµ‹</label>
    <input type="checkbox" id="edgeCheck" style="width:auto; margin:0;" onchange="processImage()">
</div>

<div class="control-group" id="edgeThresholdGroup" style="display:none; padding-bottom:0;">
    <label style="margin-bottom:0;">æ•æ„Ÿåº¦ <span id="edgeVal" class="val-display">30</span></label>
    <input type="range" id="edgeInput" min="10" max="100" step="1" value="30" oninput="document.getElementById('edgeVal').innerText = this.value; processImage()">
</div>

        <div class="control-group">
            <label>å­—ç¬¦é£æ ¼</label>
            <select id="charPreset" onchange="applyPreset()">
    <option value="default" selected>æ ‡å‡†è¯¦ç»† ($@B%...)</option>
    <option value="fine_blocks">ç»†è…»å—çŠ¶ (â–ˆâ–‡â–†â–…...)</option>
    <option value="blocks">çº¯å—çŠ¶ (â–ˆâ–“â–’â–‘)</option>
    <option value="japanese">æ—¥å¼åŠè§’ (Half-width Kana)</option>
    <option value="matrix">æ•°å­—çŸ©é˜µ (Matrix Code)</option>
    <option value="sketch">ç´ æç¬”è§¦ (Crosshatch)</option>
    <option value="glitch">æ•…éšœè‰ºæœ¯ (Glitch)</option>
    <option value="deep">æ·±é‚ƒé«˜åå·® (Deep Contrast)</option>
    <option value="binary">äºŒè¿›åˆ¶ (01)</option>
    <option value="binary_inv">äºŒè¿›åˆ¶ (10)</option>
    <option value="simple">ç®€çº¦ (. : - = + * # % @)</option>
    <option value="random">ğŸ² éšæœºæ··åˆ (Chaos Mix)</option>
    <option value="structure">ğŸ“ çº¿æ„çº¹ç† (Structure & Curves)</option>
    <option value="schematic">ğŸ—ï¸ å·¥ç¨‹åˆ¶å›¾ (Box Drawing)</option>
    <option value="geometric">å‡ ä½•å›¾å½¢ (Shapes)</option>
    <option value="borders">è¿·ä¹‹è¾¹æ¡† (Heavy Box)</option>
    <option value="diagonals">æ›²çº¿æ–œçº¿ (Curves)</option>
    <option value="full_set">ç¬¦å·è¾¹è§’æ–™</option>
            </select>
            <input type="text" id="customChars" style="margin-top:4px;font-family: monospace; letter-spacing: 1px;" value="$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,&quot;^`'. ">
        </div>

        <div class="control-group" style="flex-direction: row; justify-content: space-between;">
            <div style="display:flex; align-items:center;">
                <input type="checkbox" id="colorCheck" checked style="width:auto; margin-right:8px;">
                <span>å½©è‰²è¾“å‡º</span>
            </div>
            
            <select id="bgMode" style="width: 100px;" onchange="updateBgMode()">
                <option value="black">é»‘åº•</option>
                <option value="white">ç™½åº•</option>
            </select>
        </div>

        <button class="primary-btn" onclick="generateAndClose()">é‡æ–°ç”Ÿæˆ (Generate)</button>
        
        <div class="btn-group">
            <button class="action-btn" onclick="copyRichText()">å¤åˆ¶å¯Œæ–‡æœ¬</button>
            <button class="action-btn" onclick="copyHtmlSource()">å¤åˆ¶ HTML</button>
            <button class="download-btn btn-full" onclick="downloadAsImage()">ä¸‹è½½å›¾ç‰‡ (PNG)</button>
        </div>

        <div class="sidebar-footer">
            <div class="footer-info">
                <h6>è”ç³»ï¼š<a href="mailto:junelee220@gmail.com">junelee220#gmail.com</a></h6>
                <h6>å¦‚æœç”¨èµ·æ¥è§‰å¾—æ–¹ä¾¿ï¼Œ<a href="https://raw.githubusercontent.com/ahr-calc/ahr-calc.github.io/master/for-donation.png" style="word-break: break-all;" target="_blank">æ¬¢è¿æ‰“èµ</a>ã€‚<br>æˆ–è€…<a href="bitcoin:bc1pdmgaut0lfjcgvwt9uh3erpwma5s576jrjlrrlu7w2w7p9v2qnusqsa7phx" style="word-break: break-all;">æ¯”ç‰¹å¸</a>ã€‚</h6> 
            </div>

            <div class="iframe-wrapper">
                <iframe 
                    src="https://ahr-calc.github.io/for-donation-scan/02.html" 
                    style="
                            width: 482px;          
                            height: 242px;         
                            border: none;
                            transform: scale(0.45); 
                            transform-origin: top left; 
                            margin-bottom: -100px;
                            display: block;
                        "
                    class="ascii-embed"
                    scrolling="no"
                    title="ASCII Art"
                ></iframe>
            </div>
        </div>
    </aside>

    <main class="main-content" id="mainContent">
        <div id="ascii-output">
            <div class="placeholder-wrapper">
                <div class="ascii-art-title">
<div>
<iframe 
    src="https://ahr-calc.github.io/img2txth/ttl-ascii.html" 
    style="
            width: 100%;          /* å¼ºåˆ¶è®¾ä¸ºå›¾ç‰‡åŸå§‹å®½åº¦ */
            height: auto         /* å¼ºåˆ¶è®¾ä¸ºå›¾ç‰‡åŸå§‹é«˜åº¦ */
            border: none;
            transform: scale(3); /* ç¼©å°åˆ° 55% ä»¥é€‚åº”çº¦ 260px çš„ä¾§è¾¹æ  */
            transform-origin: center center; /* ä»é¡¶éƒ¨å±…ä¸­ç¼©æ”¾ */
            margin-bottom: -100px; /* ä¿®æ­£å› ä¸ºç¼©æ”¾ç•™ä¸‹çš„åº•éƒ¨ç©ºç™½ */
        "
    scrolling="no"
></iframe>
</div>
                </div>
            </div>
        </div>
    </main>

    <canvas id="canvas" style="display:none;"></canvas>
    <canvas id="exportCanvas" style="display:none;"></canvas>

    <script>
        let currentFontSize = 10;
        let rawAsciiText = ""; 
        let rawHtmlBody = "";  
        let currentBgIsWhite = false; 
        let generatedData = null;

        function toggleSidebar(show) {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('mobile-overlay');
            if (show) {
                sidebar.classList.add('active');
                overlay.classList.add('active');
            } else {
                sidebar.classList.remove('active');
                overlay.classList.remove('active');
            }
        }

function generateAndClose() {
    const presetSelect = document.getElementById('charPreset');
    
    // [å…³é”®ç‚¹] å¦‚æœå½“å‰æ˜¯éšæœºæ¨¡å¼ï¼Œç‚¹å‡»æŒ‰é’®æ—¶å¼ºåˆ¶åˆ·æ–°éšæœºä¸²
    if (presetSelect.value === 'random') {
        const newRandomChars = createRandomGradient();
        document.getElementById('customChars').value = newRandomChars;
        // ç¨å¾®æç¤ºä¸€ä¸‹ç”¨æˆ·å­—ç¬¦å˜äº†
        console.log("Random chars refreshed:", newRandomChars);
    }

    processImage();
    
    if (window.innerWidth <= 768) toggleSidebar(false);
}

        function showToast(message, type = 'success') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `<span>${message}</span>`;
            
            container.appendChild(toast);
            void toast.offsetWidth; 
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 2500);
        }

        function updateFontSize(val) {
            currentFontSize = val;
            document.getElementById('zoomVal').innerText = val + "px";
            if(document.getElementById('zoomInputNum')) {
        document.getElementById('zoomInputNum').value = val;
    }
            const output = document.getElementById('ascii-output');
            // é˜²æ­¢è°ƒæ•´æ»‘æ†æ—¶æŠŠæ¬¢è¿ç”»é¢å¼„ä¹±
            if (!output.querySelector('.placeholder-wrapper')) {
                output.style.fontSize = val + "px";
            }
        }

        const PRESETS = {
    // é»˜è®¤ï¼šå¹³è¡¡çš„ 69 çº§ç°åº¦
    'default': "$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~<>i!lI;:,\"^`'. ",
    
    // ç»†è…»å—çŠ¶ï¼šä½¿ç”¨ Unicode å‚ç›´å—å…ƒç´ ï¼Œä»å…¨æ»¡åˆ°ç©ºç™½ï¼Œè¿‡æ¸¡éå¸¸å¹³æ»‘
    'fine_blocks': "â–ˆâ–‡â–†â–…â–„â–ƒâ–‚  ",
    
    // çº¯å—çŠ¶ï¼šåŸæ¥çš„å—çŠ¶é£æ ¼
    'blocks': "â–ˆâ–“â–’â–‘ ", 
    
    // æ—¥å¼åŠè§’ï¼šæ¨¡æ‹ŸåŠè§’ç‰‡å‡åï¼ˆMatrix ç”µå½±é›¨æ»´æ•ˆæœä¹Ÿå¸¸ç”¨ç±»ä¼¼å­—ç¬¦ï¼‰ï¼Œç§‘æŠ€æ„Ÿå¼º
    'japanese': "ï¾˜ï½¨ï½²ï½©ï½´ï½«ï½¯ï½°ï½±ï½¶ï½·ï½¸ï½¹ï½ºï½»ï½¼ï½½ï½¾ï½¿ï¾€ï¾ï¾‚ï¾ƒï¾„ï¾…ï¾†ï¾‡ï¾ˆï¾‰ï¾Šï¾‹ï¾Œï¾ï¾ï¾ï¾ï¾‘ï¾’ï¾“ï¾”ï¾•ï¾–ï¾—ï¾™ï¾šï¾›ï¾œï¾1234567890:. ",
    
    // æ•°å­—çŸ©é˜µï¼šåå…­è¿›åˆ¶é£æ ¼ï¼Œé€‚åˆé»‘åº•ç»¿å­—
    'matrix': "800813579ACEF01011 ",
    
    // ç´ æç¬”è§¦ï¼šä½¿ç”¨äº¤å‰çº¿æ¡æ¨¡æ‹Ÿç´ æé˜´å½± (X, #, /, \)
    'sketch': "##XX==++//--..  ",
    
    // æ•…éšœè‰ºæœ¯ï¼šæ··åˆç‰¹æ®Šç¬¦å·ï¼Œåˆ¶é€ æ•°æ®æŸåçš„è§†è§‰æ„Ÿ
    'glitch': "Â¶Â§â–“â–’â–‘$Ã˜Ã†Â¥?Â¿!Â¡|/;:,. ",
    
    // æ·±é‚ƒé«˜åå·®ï¼šé‡å¤å­—ç¬¦ä»¥å‡å°‘ä¸­é—´è‰²è°ƒï¼Œäº§ç”Ÿç±»ä¼¼å‰ªå½±æˆ–ç‰ˆç”»çš„æ•ˆæœ
    'deep': "â–ˆâ–ˆâ–ˆâ–ˆâ–“â–“â–“â–“â–’â–’â–’â–’â–‘â–‘â–‘â–‘++++----....    ",
    
    // äºŒè¿›åˆ¶
    'binary': "101001 ",   
    'binary_inv': "010110 ",
    
    // ç®€çº¦
    'simple': "@%#*+=-:. ",
    'structure': "@#8&WMX/\\|(){}[]?-_+~<>*!;:,\"^`'. ",
    'schematic': "â–ˆâ–“â–’â–‘â•¬â•«â•ªâ•©â•¨â•§â•¤â•¥â•™â•˜â•“â•’â•‘â”‚â”€.. ",
    'geometric': "â–ˆâ–“â–²â–¼â—â—¢â—£â—¤â—¥â˜…ã€’ãŠ£â—†â–’â—â—‹â–¡â–³â–½â—‡â–‘  ",
    'borders': "â–ˆâ–“â–’â•¬â•«â•ªâ• â•¡â•¢â•£â•¤â•¥â•¦â•§â•¨â•©â•”â•—â•šâ•â•‘â•â•â•Ÿâ• â•¡â”‚â”¤â”â””â”´â”¬â”¼â”€â–‘  ",
    'diagonals': "â–ˆâ–“â–’â•³â•±â•²â•­â•®â•¯â•°  ",
    'full_set': "â–ˆâ–“â–€â–„â–Œâ–â—â—¢â—£â—¤â—¥â˜…ãŠ£ã€’â•¬â•«â•ªâ–’â–²â–¼â•”â•—â•šâ•â• â•£â•¦â•©â•â•‘â•­â•®â•¯â•°â•±â•²â•³â—â—‹â–¡â–³â–½â—‡â–‘â”Œâ”â””â”˜â”œâ”¤â”¬â”´â€ â€»  "
        };

        const BAYER_MATRIX_4x4 = [
            [ 0,  8,  2, 10], [12,  4, 14,  6], [ 3, 11,  1,  9], [15,  7, 13,  5]
        ];

        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('imageInput');

function createRandomGradient() {
    // è·å–é™¤ random ä»¥å¤–çš„æ‰€æœ‰é¢„è®¾ key
    const keys = Object.keys(PRESETS).filter(k => k !== 'random');
    const targetLength = 64; // ç›®æ ‡æ¢¯åº¦é•¿åº¦
    let result = "";

    for (let i = 0; i < targetLength; i++) {
        // A. éšæœºé€‰ä¸€ä¸ªé¢„è®¾é£æ ¼
        const randomKey = keys[Math.floor(Math.random() * keys.length)];
        const sourceStr = PRESETS[randomKey];

        // B. æ ¹æ®å½“å‰ i çš„ä½ç½®ï¼Œå»é€‰å¯¹åº”é£æ ¼é‡Œç›¸åŒäº®åº¦çš„å­—ç¬¦
        // è¿™æ ·ä¿è¯äº†æ··åˆåçš„å­—ç¬¦ä¸²ä¾ç„¶æ˜¯ä»é»‘åˆ°ç™½çš„æœ‰åºæ’åˆ—
        const progress = i / targetLength;
        const sourceIndex = Math.floor(progress * sourceStr.length);
        
        result += sourceStr[sourceIndex] || sourceStr[sourceStr.length - 1];
    }
    return result;
}

// 2. ä¿®æ”¹åçš„åº”ç”¨å‡½æ•°
function applyPreset() {
    const val = document.getElementById('charPreset').value;
    
    if (val === 'random') {
        // ç¬¬ä¸€æ¬¡åˆ‡æ¢åˆ° Random æ—¶ï¼Œç”Ÿæˆä¸€ä¸ªåˆå§‹å€¼
        document.getElementById('customChars').value = createRandomGradient();
        showToast("éšæœºæ¨¡å¼ï¼šç‚¹å‡»ã€Œé‡æ–°ç”Ÿæˆã€å¯åˆ·æ–°å­—ç¬¦ç»„åˆ");
    } else if (PRESETS[val]) {
        document.getElementById('customChars').value = PRESETS[val];
    }
    processImage(); 
}

        function updateBgMode() {
            const mode = document.getElementById('bgMode').value;
            const mainContent = document.getElementById('mainContent');
            const output = document.getElementById('ascii-output');
            
            if (mode === 'white') {
                currentBgIsWhite = true;
                mainContent.style.backgroundColor = '#ffffff';
                output.style.color = '#000000';
            } else {
                currentBgIsWhite = false;
                mainContent.style.backgroundColor = '#000000';
                output.style.color = '#eeeeee';
            }
            processImage(); 
        }

        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            if (e.dataTransfer.files[0]) {
                fileInput.files = e.dataTransfer.files;
                processImage();
                if (window.innerWidth <= 768) toggleSidebar(false);
            }
        });
        
        fileInput.addEventListener('change', () => {
            processImage();
            if (window.innerWidth <= 768) toggleSidebar(false);
        });

        function getGray(r, g, b) {
            return 0.299 * r + 0.587 * g + 0.114 * b;
        }

        function processImage() {
            if (!fileInput.files || !fileInput.files[0]) return;

            const widthInput = parseInt(document.getElementById('widthInput').value);
            const ratioInput = parseFloat(document.getElementById('ratioInput').value);
            const ditherAlgo = document.getElementById('ditherAlgo').value;
            const useColor = document.getElementById('colorCheck').checked;
            const customChars = document.getElementById('customChars').value;
            const invertGray = currentBgIsWhite; 

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = () => generateAscii(img, widthInput, ratioInput, ditherAlgo, useColor, invertGray, customChars);
                img.src = event.target.result;
            }
            reader.readAsDataURL(fileInput.files[0]);
        }

/* ============================================================
   æ”¾åœ¨ script æ ‡ç­¾å†…çš„ generateAscii å‡½æ•°ï¼Œè¯·å®Œå…¨æ›¿æ¢æ—§ç‰ˆæœ¬
   ============================================================ */
function generateAscii(img, targetWidth, fontRatio, ditherAlgo, useColor, invertGray, charSet) {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const output = document.getElementById('ascii-output');

    // 1. è·å–è¾¹ç¼˜æ£€æµ‹å¼€å…³å’Œé˜ˆå€¼
    const useEdge = document.getElementById('edgeCheck').checked;
    const edgeThreshold = parseInt(document.getElementById('edgeInput').value) || 30;

    // æ§åˆ¶ UI æ˜¾ç¤º/éšè— (æ”¾åˆ°è¿™é‡Œé¡ºæ‰‹å¤„ç†ï¼Œæˆ–è€…æ”¾åœ¨ onchange é‡Œ)
    document.getElementById('edgeThresholdGroup').style.display = useEdge ? 'flex' : 'none';

    // 2. è°ƒæ•´ç”»å¸ƒå¤§å°
    const w = targetWidth;
    const h = Math.floor((w / img.width) * img.height * fontRatio);
    
    canvas.width = w;
    canvas.height = h;
    ctx.drawImage(img, 0, 0, w, h);

    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;

    // 3. å‡†å¤‡äº®åº¦æ•°ç»„ (Sobel éœ€è¦å…ˆè½¬ç°åº¦)
    // æ³¨æ„ï¼šå¦‚æœæ˜¯è¾¹ç¼˜æ£€æµ‹æ¨¡å¼ï¼Œæˆ‘ä»¬ä¸åè½¬ç°åº¦ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦è®¡ç®—åŸå§‹æ¢¯åº¦
    let luminance = new Float32Array(w * h);
    for (let i = 0; i < w * h; i++) {
        // æ ‡å‡†ç°åº¦å…¬å¼
        luminance[i] = 0.299 * data[i*4] + 0.587 * data[i*4+1] + 0.114 * data[i*4+2];
    }

    /* ---------------------------------------------------------
       åˆ†æ”¯ A: è¾¹ç¼˜æ£€æµ‹æ¨¡å¼ (Sobel Operator)
       --------------------------------------------------------- */
    if (useEdge) {
        generatedData = {
            width: w,
            height: h,
            charGrid: [],
            colorGrid: [],
            bgColor: currentBgIsWhite ? '#ffffff' : '#000000'
        };

        let htmlParts = [];
        let asciiParts = [];

        // Sobel å·ç§¯æ ¸ (ç”¨äºæ£€æµ‹æ¨ªå‘å’Œçºµå‘å˜åŒ–)
        // Gx æ£€æµ‹ç«–çº¿, Gy æ£€æµ‹æ¨ªçº¿
        for (let y = 0; y < h; y++) {
            let lineHtml = "";
            let rowChars = [];
            let rowColors = [];

            for (let x = 0; x < w; x++) {
                // å¤„ç†è¾¹ç•Œï¼Œè¾¹ç•Œé»˜è®¤ä¸ºç©º
                if (x === 0 || x === w - 1 || y === 0 || y === h - 1) {
                    rowChars.push(" ");
                    rowColors.push(generatedData.bgColor);
                    lineHtml += "&nbsp;";
                    continue;
                }

                // æå–å‘¨å›´ 3x3 åƒç´ çš„äº®åº¦
                // TL T TR
                // L  C  R
                // BL B BR
                const idx = y * w + x;
                const tl = luminance[idx - w - 1];
                const t  = luminance[idx - w];
                const tr = luminance[idx - w + 1];
                const l  = luminance[idx - 1];
                const r  = luminance[idx + 1];
                const bl = luminance[idx + w - 1];
                const b  = luminance[idx + w];
                const br = luminance[idx + w + 1];

                // Sobel è®¡ç®—å…¬å¼
                const gx = -tl - 2*l - bl + tr + 2*r + br;
                const gy = -tl - 2*t - tr + bl + 2*b + br;

                // æ¢¯åº¦å¹…å€¼ (å˜åŒ–æœ‰å¤šå‰§çƒˆ)
                const mag = Math.sqrt(gx * gx + gy * gy);

                let char = " ";
                
                // å¦‚æœå˜åŒ–å¼ºåº¦è¶…è¿‡é˜ˆå€¼ï¼Œè¯´æ˜è¿™é‡Œæœ‰è¾¹
                if (mag > edgeThreshold) {
    const angle = Math.atan2(gy, gx) * (180 / Math.PI);
    const absAngle = Math.abs(angle);

    if (absAngle < 22.5 || absAngle > 157.5) {
        char = "â”‚"; // ä½¿ç”¨åˆ¶è¡¨ç¬¦ç«–çº¿ï¼Œæ¯” | æ›´è¿è´¯
    } else if (absAngle > 67.5 && absAngle < 112.5) {
        char = "â”€"; // ä½¿ç”¨åˆ¶è¡¨ç¬¦æ¨ªçº¿ï¼Œæ¯” - æ›´è¿è´¯
    } else if (angle > 0) {
        char = "â•²"; // [æ–°] ä½¿ç”¨ Box Drawing Diagonals
    } else {
        char = "â•±"; // [æ–°] ä½¿ç”¨ Box Drawing Diagonals
    }
    
    // å¢å¼ºæ¨¡å¼
    if (mag > edgeThreshold * 3) {
         if (char === 'â”‚') char = 'â•‘'; // åŒçº¿ç«–
         if (char === 'â”€') char = 'â•'; // åŒçº¿æ¨ª
         if (char === 'â•±' || char === 'â•²') char = 'â•³'; // äº¤å‰
    }
}

                // é¢œè‰²å¤„ç†ï¼šå¦‚æœå‹¾é€‰å½©è‰²ï¼Œä¸”æ˜¯è¾¹ç¼˜ï¼Œåˆ™ä¿ç•™åŸè‰²
                // å¦åˆ™ä½¿ç”¨å•è‰²
                let colorStr = "";
                if (char !== " ") {
                    if (useColor) {
                        // ç¨å¾®å¢å¼ºä¸€ä¸‹è¾¹ç¼˜çš„é¢œè‰²é¥±å’Œåº¦
                        const rVal = data[idx*4];
                        const gVal = data[idx*4+1];
                        const bVal = data[idx*4+2];
                        colorStr = `rgb(${rVal},${gVal},${bVal})`;
                    } else {
                        colorStr = currentBgIsWhite ? '#000000' : '#ffffff';
                    }
                } else {
                    colorStr = currentBgIsWhite ? '#ffffff' : '#000000';
                }

                // å­˜å…¥æ•°æ®
                rowChars.push(char);
                asciiParts.push(char);
                rowColors.push(colorStr);

                // HTML è½¬ä¹‰
                let displayChar = char;
                if (displayChar === " ") displayChar = "&nbsp;";
                if (displayChar === "<") displayChar = "&lt;";
                if (displayChar === ">") displayChar = "&gt;";
                
                lineHtml += `<span style="color:${colorStr}">${displayChar}</span>`;
            }
            generatedData.charGrid.push(rowChars);
            generatedData.colorGrid.push(rowColors);
            htmlParts.push(lineHtml + "<br>");
            asciiParts.push("\n");
        }

        rawHtmlBody = htmlParts.join("");
        rawAsciiText = asciiParts.join("");
        output.innerHTML = rawHtmlBody;
        output.style.fontSize = currentFontSize + "px";
        return; // è¾¹ç¼˜æ£€æµ‹æ¨¡å¼ç»“æŸï¼Œç›´æ¥è¿”å›
    }

    /* ---------------------------------------------------------
       åˆ†æ”¯ B: æ ‡å‡†äº®åº¦æ˜ å°„æ¨¡å¼ (åŸæœ‰çš„é€»è¾‘)
       --------------------------------------------------------- */
    
    // å¦‚æœæ²¡æœ‰åè½¬ç°åº¦ï¼ˆé€šå¸¸é»‘åº•ç™½å­—æ—¶éœ€è¦åè½¬ï¼Œè¶Šäº®è¶Šç™½ï¼‰ï¼Œè¿™é‡Œå¤„ç†ä¸€ä¸‹
    // æ³¨æ„ï¼šä¸Šé¢çš„ luminance æ˜¯åŸå§‹äº®åº¦ã€‚
    // æ—§ä»£ç é€»è¾‘é‡Œï¼ŒinvertGray = currentBgIsWhiteã€‚
    // å¦‚æœæ˜¯ç™½åº•(true)ï¼Œæˆ‘ä»¬å¸Œæœ›é»‘å­—(0)ï¼Œæ‰€ä»¥äº®åº¦é«˜(255)çš„åœ°æ–¹åº”è¯¥æ˜¯ç©ºç™½(indexå¤§)ã€‚
    // è¿™é‡Œä¿æŒæ—§ä»£ç é€»è¾‘ï¼š
    if (invertGray) {
        for(let i=0; i<w*h; i++) luminance[i] = 255 - luminance[i];
    }

    // --- è¿™é‡Œçš„ä»£ç å°±æ˜¯åŸæœ¬çš„ Dithering å’Œ Char Mapping é€»è¾‘ ---
    // ä¸ºäº†èŠ‚çœç¯‡å¹…ï¼Œè¿™é‡Œå¤ç”¨ä½ åŸæœ‰çš„ä»£ç é€»è¾‘ï¼Œåªéœ€è¦æŠŠä¸Šé¢çš„ Sobel å—æ’åœ¨åŸæœ¬é€»è¾‘ä¹‹å‰
    // ä¸‹é¢æ˜¯åŸæœ‰çš„ Dithering + Mapping ä»£ç ï¼š
    
    const rampLen = charSet.length;

    // ... (æ­¤å¤„ä¿ç•™åŸæœ‰çš„ Bayer / Floyd-Steinberg æŠ–åŠ¨ä»£ç ) ...
    // ä¸ºç¡®ä¿å®Œæ•´æ€§ï¼Œæˆ‘ç®€å†™å¦‚ä¸‹ï¼Œè¯·ä¿ç•™ä½ åŸæœ¬çš„æŠ–åŠ¨é€»è¾‘å—
    if (ditherAlgo === 'bayer') {
        // ... Bayer é€»è¾‘ ...
        const bayerFactor = 40.0; 
        for (let y = 0; y < h; y++) {
             for (let x = 0; x < w; x++) {
                 const idx = y * w + x;
                 const matrixValue = BAYER_MATRIX_4x4[y % 4][x % 4];
                 const offset = ((matrixValue / 15.0) - 0.5) * bayerFactor;
                 luminance[idx] = Math.max(0, Math.min(255, luminance[idx] + offset));
             }
        }
    } else if (ditherAlgo !== 'none') {
        // ... FS / Atkinson / Stucki é€»è¾‘ ...
        // è¯·ä¿ç•™åŸæœ‰çš„ distribute å‡½æ•°å’Œå¾ªç¯
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                const idx = y * w + x;
                const oldVal = luminance[idx];
                const rampIndex = Math.floor(Math.max(0, Math.min(255, oldVal)) / 255 * (rampLen - 1));
                const newVal = (rampIndex / (rampLen - 1)) * 255;
                const error = oldVal - newVal;
                
                const distribute = (dx, dy, fraction) => {
                    if (x + dx >= 0 && x + dx < w && y + dy < h) {
                        luminance[idx + dy * w + dx] += error * fraction;
                    }
                };
                
                if (ditherAlgo === 'fs') {
                    distribute(1,0,7/16); distribute(-1,1,3/16); distribute(0,1,5/16); distribute(1,1,1/16);
                } else if (ditherAlgo === 'atkinson') {
                    const e = 1/8;
                    distribute(1,0,e); distribute(2,0,e); distribute(-1,1,e); distribute(0,1,e); distribute(1,1,e); distribute(0,2,e);
                } else if (ditherAlgo === 'stucki') {
                    const s = 1/42;
                    distribute(1,0,8*s); distribute(2,0,4*s); distribute(-2,1,2*s); distribute(-1,1,4*s); distribute(0,1,8*s); distribute(1,1,4*s); distribute(2,1,2*s); distribute(-2,2,1*s); distribute(-1,2,2*s); distribute(0,2,4*s); distribute(1,2,2*s); distribute(2,2,1*s);
                }
            }
        }
    }

    // Mapping å¾ªç¯
    let htmlParts = []; 
    let asciiParts = [];
    generatedData = {
        width: w,
        height: h,
        charGrid: [],
        colorGrid: [],
        bgColor: currentBgIsWhite ? '#ffffff' : '#000000'
    };

    for (let y = 0; y < h; y++) {
        let lineHtml = "";
        let rowChars = [];
        let rowColors = [];
        
        for (let x = 0; x < w; x++) {
            const idx = y * w + x;
            let gray = Math.max(0, Math.min(255, luminance[idx]));
            const charIndex = Math.floor((1 - (gray / 255)) * (rampLen - 1));
            let char = charSet[charIndex] || " ";

            rowChars.push(char);
            asciiParts.push(char);

            let displayChar = char;
            if (char === " ") displayChar = "&nbsp;";
            else if (char === "<") displayChar = "&lt;";
            else if (char === ">") displayChar = "&gt;";
            else if (char === '"') displayChar = "&quot;";
            else if (char === "&") displayChar = "&amp;";

            if (useColor) {
                const r = data[idx * 4];
                const g = data[idx * 4 + 1];
                const b = data[idx * 4 + 2];
                const colorStr = `rgb(${r},${g},${b})`;
                rowColors.push(colorStr);
                lineHtml += `<span style="color:${colorStr}">${displayChar}</span>`;
            } else {
                const monoColor = currentBgIsWhite ? '#000' : '#fff';
                rowColors.push(monoColor);
                lineHtml += displayChar;
            }
        }
        
        generatedData.charGrid.push(rowChars);
        generatedData.colorGrid.push(rowColors);
        htmlParts.push(lineHtml + "<br>");
        asciiParts.push("\n");
    }
    
    rawHtmlBody = htmlParts.join("");
    rawAsciiText = asciiParts.join("");
    output.innerHTML = rawHtmlBody;
    output.style.fontSize = currentFontSize + "px";
}

        async function copyRichText() {
            if (!rawHtmlBody) return showToast("è¯·å…ˆç”Ÿæˆå›¾ç‰‡ï¼", "error");
            const bgColor = currentBgIsWhite ? '#ffffff' : '#000000';
            const textColor = currentBgIsWhite ? '#000000' : '#ffffff';

            const fullHtml = `
                <div style="background-color: ${bgColor}; color: ${textColor}; font-family: 'Courier New', Courier, monospace; font-size: ${currentFontSize}px; line-height: 1.0; white-space: pre; display: inline-block; padding: 10px; border-radius: 5px;">
                    ${rawHtmlBody}
                </div>`;

            try {
                const blobHtml = new Blob([fullHtml], { type: 'text/html' });
                const blobText = new Blob([rawAsciiText], { type: 'text/plain' });
                await navigator.clipboard.write([new ClipboardItem({'text/html': blobHtml, 'text/plain': blobText})]);
                showToast(`å·²å¤åˆ¶ï¼(å­—å·: ${currentFontSize}px)`);
            } catch (err) {
                showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™", "error");
            }
        }

        function copyHtmlSource() {
            if (!rawHtmlBody) return showToast("è¯·å…ˆç”Ÿæˆå›¾ç‰‡ï¼", "error");
            const bgColor = currentBgIsWhite ? '#ffffff' : '#000000';
            const textColor = currentBgIsWhite ? '#000000' : '#ffffff';
            
            const wrapperStart = `<div style="background-color: ${bgColor}; color: ${textColor}; font-family: 'Courier New', Courier, monospace; font-size: ${currentFontSize}px; line-height: 1.0; white-space: pre; display: inline-block; padding: 10px; border-radius: 5px;">`;
            const finalHtml = wrapperStart + "\n" + rawHtmlBody + "\n</div>";
            
            navigator.clipboard.writeText(finalHtml).then(() => showToast(`HTML ä»£ç å·²å¤åˆ¶ï¼(å­—å·: ${currentFontSize}px)`));
        }

        function downloadAsImage() {
            if (!generatedData) return showToast("è¯·å…ˆç”Ÿæˆå›¾ç‰‡ï¼", "error");

            const exportCanvas = document.getElementById('exportCanvas');
            const ctx = exportCanvas.getContext('2d');
            
            const fontSize = 12; 
            const lineHeight = fontSize; 
            const fontFamily = 'Courier New, monospace';
            const charWidth = fontSize * 0.6; 
            
            const canvasWidth = Math.ceil(generatedData.width * charWidth) + 40;
            const canvasHeight = Math.ceil(generatedData.height * lineHeight) + 40;

            exportCanvas.width = canvasWidth;
            exportCanvas.height = canvasHeight;

            ctx.fillStyle = generatedData.bgColor;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            ctx.font = `${fontSize}px ${fontFamily}`;
            ctx.textBaseline = 'top';

            const grid = generatedData.charGrid;
            const colors = generatedData.colorGrid;

            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    ctx.fillStyle = colors[y][x];
                    ctx.fillText(grid[y][x], 20 + (x * charWidth), 20 + (y * lineHeight));
                }
            }

            const link = document.createElement('a');
            link.download = 'ascii-art.png';
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
            showToast("å›¾ç‰‡ä¸‹è½½å·²å¼€å§‹");
        }
    </script>
</body>
</html>
